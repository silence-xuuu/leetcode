/*
报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：
1.     1
2.     11
3.     21
4.     1211
5.     111221
1 被读作  "one 1"  ("一个一") , 即 11。
11 被读作 "two 1s" ("两个一"）, 即 21。
21 被读作 "one 2",  "one 1" （"一个二" ,  "一个一") , 即 1211。
给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。
注意：整数顺序将表示为一个字符串。

输入: 4
输出: "1211"
*/

char *count1(char *s, int n)
{
    int count=0;
    if (n == 1)
        return s;
    else
    {
        char ch[10000];
        char *p = ch;
        while (*s!='\0')
        {
            count = 1;
            while (*s==*(s+1))
            {
                count++;
                s++;
            }
            *p++ = (char)(count+'0');
            *p++ = *s++;
        }
        return count1(ch, n - 1);
    }
}

char *countAndSay(int n)
{
    return count1("1", n);
}

/*
0 ms	6.9 MB

思路：递归法
定义一个子函数将递归的某一步写清楚后在主函数中调用递归的模型。

思考感悟：
1递归法玄之又玄hhh，在一个子函数不能完全实现递归时可以创建二层的子函数完成递归。
*/
