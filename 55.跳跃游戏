/*
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。

示例 1:
输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。

示例 2:
输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
*/

class Solution {
public:
    bool canJump(vector<int>& nums) {
        int length=nums.size(),temp=0;
        for(int i=0;i<length;i++){
            if(temp+i+1>=length) return true;   //当前可以直接跳跃至终点
            if(temp<0) return false;            //可跳跃最大距离不够
            if(nums[i]>=temp) temp=nums[i];     //可跳跃距离更新
            temp--;
        }
        return false;
    }
};

/*
4ms 100%

思路：记录当前位置所能到达的最远距离，如果超过最后则返回true，最远距离小于0则无法移动。

思考感悟：
1、此题的重点在于解题的思路，记录最远跳跃长度或跳跃总距离都可行。
2、在解数组相关题时，可以多多用到原地标记的方法，利用迭代的方法解题。
3、此题在第一次提交时，忘记了写距离不够的退出条件，导致答案错误。
*/
