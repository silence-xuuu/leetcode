/*
给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

输入: 123
输出: 321
*/

int reverse(int x){
    int result = 0;
    while(x) {
        if(result > 0x7fffffff / 10 || result < (signed int)0x80000000/10){
            return 0;
        }
        result *= 10;
        result += x%10;
        x /= 10;
    }
    return result;
}

/*
原始思路：暴力迭代法
存入示例后迭代反序取余读取数字，每次迭代将原数据乘十加入新的数字。
溢出判定：通过比较大小判断是否在INT型数字内，若超出则返回0。


现在思路：暴力迭代法
优点：代码较为简洁清楚，将是否溢出的条件放在循环中相较原方法可以减少前一步的迭代时间，只使用一个变量储存返回值减少重复代值计算的时间。

思考感悟：
1.循环内外都有的语句可以尝试都放在循环内进行。
2.在题目所给范围是int型所代表的整个范围时，用16进制的int表示法不容易出错。
3.在int的类型定义下不能直接将temp值与数字类型的比较大小，需要改成十六进制的表示法。
*/
