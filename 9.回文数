/*
判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

输入: 121
输出: true
*/

bool isPalindrome(int x){
    //负数一定不是回文数
    if(x < 0)
    return false;
    //123321
    //将这个数的后面一半拿下来，组成一个新的整数
    //统计整数的的位数数
    int tmp = x;
    int count = 0;
    int nnum = 0;
    while(tmp)
    {
        count++;
        tmp/=10;
    }
    
    //取后面一半的位数 组成新整数
    for(int i = 0; i<count/2; i++)
    {
    //只有第一次拿下来是个 一位数，其余每次拿下来都要在上一次的nnum基础上*10
        if(i==0)
         {
           nnum = x%10;
           x /= 10;
         }
        else
         {
           nnum =  (x%10) + nnum*10;
           x /= 10;         
          }
    }
    
     //比较新的整数 和 剩余部分整数 大小
    if(count %2 ==0)
    {
        //说明整数是偶数位，取count/2位数组成新的整数
        if(x == nnum)
            return true;
        return false;
        
    }
    else
    {
        //整数是奇数位，取count/2位数 组成新的整数后，还需要将剩余整数再去掉最后一位
        x /= 10;
         if(x == nnum)
            return true;
        return false;
        
    }  
}

/*
12 ms	6.9 MB

原始思路：
先判断是否为负数&是否为末位为零的数。
然后另取变量使其等于原数的反序数，比较与原数的大小。

现在思路：
先判断是否为负数。
计算该数的位数，摘下前一半的位数，与后一半作比较。
优点：将数字分为两半，减少了迭代的时间，效率更高。

思考感悟：
1.此题有多重不同解法，所用时间相差不太大。时间快的代码较复杂。
2.在迭代的题目中可以留心是否可以不需要遍历所有数字就能解决问题，可以提高程序的效率。
*/
