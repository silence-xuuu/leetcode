/*
给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。
注意:
给定的整数保证在32位带符号整数的范围内。
你可以假定二进制数不包含前导零位。

输入: 5
输出: 2
解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。
*/

int findComplement(int num){
    long n,count=1,result=0;
    while(num){
        n=num%2;
        num/=2;
        if(n==0) result+=count;
        count*=2;
    }
    return result;
}

/*
0ms 100%
67% 79.27%

思路：
定义一个单次乘二的变量代表某一位的位权，在该数不为零的情况下当余数为0时将位权值加到result上。

思考感悟：
1.为了减少用数组存储带来的时间消耗和运算的复杂，采用单次循环乘二的方法表示位权值。
2.为了减少将数位反转带来的时间消耗，直接采用单次循环判断余数的方法改变result值，并在下一次循环的开始重新初始化。
3.算法题中涉及到二进制转化的题目使用较多的是循环取余除二法（目前做的都是这样），同样由于这种方法不需要额外空间会在时间空间复杂度上有着一定优越性。
*/
