/*
给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
*/

int left = 0;
int right = numsSize - 1;


while(left <= right)
{
    if(nums[left] == val)
    {
        nums[left] = nums[right];
        right--;
        numsSize--;
    }
    else
    {
        left++;
    }
}


if(left == 0 && right == 0)
    return NULL;


return numsSize;   

/*
4 ms	7.3 MB

思路：
因为不考虑变化后的元素的位置，在遍历元素时，当元素值与目标值不相等，将末尾的元素与当前元素交换位置并记录次数。

思考感悟：
1.在数组的元素值改变的题目中，可以适当采用下标交换或者更换下标覆盖的方法。
2.在排序数组中，由于不考虑位置变化，通过直接交换位置或直接下标覆盖的方法可以通过减少重复遍历、减少多次存储带来的时间和空间上的不必要消耗。
*/
